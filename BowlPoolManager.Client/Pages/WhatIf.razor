@page "/what-if"
@using BowlPoolManager.Core.Domain
@using BowlPoolManager.Core
@using BowlPoolManager.Core.Helpers
@using BowlPoolManager.Client.Helpers
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject AuthenticationStateProvider AuthStateProvider

<PageTitle>Path to Victory</PageTitle>

<style>
    /* 1. SCROLL CONTAINER */
    .matrix-container {
        display: block;
        width: 100%;
        max-width: 100%;
        height: calc(100vh - 190px); 
        overflow: auto; 
        border: 1px solid #dee2e6;
        background-color: white;
        position: relative;
        -webkit-overflow-scrolling: touch;
    }

    /* 2. TABLE BASE */
    .matrix-table {
        border-collapse: separate; 
        border-spacing: 0;
        min-width: 100%;
        margin-bottom: 0;
    }

    /* 3. PREVENT WRAPPING */
    .matrix-table th, 
    .matrix-table td {
        white-space: nowrap;
        vertical-align: middle;
    }

    /* 4. STICKY HEADERS (Top Row) */
    .matrix-table th {
        position: sticky;
        top: 0;
        z-index: 20; 
        background-color: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        padding: 0.5rem;
        text-align: center;
        box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.1);
    }

    /* 5. STICKY FIRST COLUMN (Left Column) */
    .matrix-table td.sticky-col {
        position: sticky;
        left: 0;
        z-index: 10; 
        background-color: #fff !important; 
        border-right: 2px solid #dee2e6;
        font-weight: 500;
        min-width: 200px; 
        box-shadow: 2px 0 2px -1px rgba(0, 0, 0, 0.1);
    }

    /* 6. CORNER CELL (Top-Left Intersection) */
    .matrix-table th.corner-header {
        position: sticky;
        left: 0;
        top: 0;
        z-index: 30; 
        background-color: #e9ecef !important;
        border-right: 2px solid #dee2e6;
        min-width: 200px;
    }

    /* 7. ROW HOVER */
    .matrix-table tr:hover td { background-color: #f1f3f5; }
    .matrix-table tr:hover td.sticky-col { background-color: #e9ecef !important; }

    /* Sim Controls */
    .sim-control {
        cursor: pointer;
        font-size: 0.75rem;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #ced4da;
        margin: 2px;
        display: block;
        width: 100%;
        text-align: center;
    }
    .sim-control:hover { filter: brightness(0.95); }
    .sim-control.active-win {
        background-color: #198754; 
        color: white;
        border-color: #198754;
    }
    .sim-control.active-loss {
        opacity: 0.4;
        text-decoration: line-through;
    }
    
    /* Colors */
    .cell-win { background-color: #d1e7dd !important; color: #0f5132; }
    .cell-loss { background-color: #f8d7da !important; color: #842029; }
</style>

<div class="container-fluid mt-3 px-4">
    <div class="d-flex justify-content-between align-items-end mb-3">
        
        @* LEFT SIDE: Title + Pool Selector *@
        <div class="d-flex flex-column gap-2">
            <div class="d-flex align-items-center gap-3">
                <h1 class="h3 fw-bold mb-0"><i class="bi bi-signpost-split-fill text-primary"></i> Path to Victory</h1>
            </div>

            @* POOL SELECTOR *@
            @if(poolList.Count > 1)
            {
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small fw-bold">Pool:</span>
                    <select class="form-select form-select-sm shadow-sm" style="width: auto; min-width: 200px;" @onchange="OnPoolChanged">
                        @foreach(var pool in poolList)
                        {
                            <option value="@pool.Id" selected="@(pool.Id == selectedPoolId)">@pool.Name</option>
                        }
                    </select>
                </div>
            }
        </div>

        @* RIGHT SIDE: Actions *@
        <div>
             @if (HasActiveSimulation)
             {
                <button class="btn btn-outline-danger btn-sm" @onclick="ResetSimulation">
                    <i class="bi bi-arrow-counterclockwise"></i> Reset to Reality
                </button>
             }
        </div>
    </div>

    @if (isLoading)
    {
        <div class="d-flex justify-content-center py-5">
            <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
        </div>
    }
    else
    {
        <div class="matrix-container shadow-sm">
            <table class="table mb-0 matrix-table table-bordered">
                <thead>
                    <tr>
                        <th class="corner-header">
                            <div class="d-flex justify-content-between text-muted small">
                                <span>Player</span>
                                <span>Proj. Score</span>
                            </div>
                        </th>
                        @foreach (var game in games)
                        {
                            <th>
                                <div class="small fw-bold mb-1" style="font-size: 0.7rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="@game.BowlName">
                                    @game.BowlName
                                </div>
                                <div class="badge bg-light text-secondary border mb-2">@game.PointValue pts</div>
                                
                                @* UNIFIED CONTROL LOGIC: All games (Final or Future) are editable *@
                                @{
                                    var options = GetSelectableTeams(game);
                                }
                                
                                @if(options.Count <= 2) 
                                {
                                    @* Simple Toggle for Head-to-Head *@
                                    <div class="d-flex flex-column gap-1">
                                        @foreach(var team in options)
                                        {
                                            <div class="sim-control @GetSimClass(game.Id, team, options)" 
                                                 @onclick="() => ToggleSimWinner(game.Id, team)">
                                                @team
                                            </div>
                                        }
                                    </div>
                                }
                                else
                                {
                                    @* Dropdown for Playoffs/Many Options *@
                                    <select class="form-select form-select-sm" style="font-size: 0.75rem;" 
                                            value="@(simulatedWinners.ContainsKey(game.Id) ? simulatedWinners[game.Id] : "")"
                                            @onchange="@(e => SetSimWinner(game.Id, e.Value?.ToString()))">
                                        <option value="">-- Select Winner --</option>
                                        @foreach(var team in options)
                                        {
                                            <option value="@team">@team</option>
                                        }
                                    </select>
                                }
                            </th>
                        }
                    </tr>
                </thead>
                <tbody>
                    @foreach (var row in projectedStandings)
                    {
                        <tr>
                            <td class="sticky-col">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span class="text-truncate" style="max-width: 160px;" title="@row.Entry.PlayerName">
                                        <span class="text-muted small me-1">@row.Rank.</span>
                                        @row.Entry.PlayerName
                                    </span>
                                    <span class="badge bg-primary rounded-pill">@row.Score</span>
                                </div>
                            </td>

                            @foreach (var game in games)
                            {
                                var pick = row.Entry.Picks != null && row.Entry.Picks.ContainsKey(game.Id) ? row.Entry.Picks[game.Id] : "";
                                <td class="text-center @GetCellClass(game, pick)">
                                    @if (!string.IsNullOrEmpty(pick))
                                    {
                                        <span style="font-size: 0.85rem;">@pick</span>
                                    }
                                    else
                                    {
                                        <span class="text-muted">-</span>
                                    }
                                </td>
                            }
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
</div>

@code {
    private bool isLoading = true;
    private List<BowlGame> games = new();
    private List<BowlGame> allGames = new();
    
    // Raw Data
    private List<BracketEntry> allEntries = new();
    private List<BowlPool> poolList = new();
    
    // Filtered State
    private string selectedPoolId = "";
    private List<BracketEntry> filteredEntries = new();
    
    // Simulation State
    private Dictionary<string, string> simulatedWinners = new();
    private List<LeaderboardRow> projectedStandings = new();

    // Smart Bracket Map: Key = TargetGameId, Value = List of Games that feed into it
    private ILookup<string, BowlGame>? _feederMap;

    [SupplyParameterFromQuery(Name = "poolId")]
    public string? QueryPoolId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var gamesTask = Http.GetFromJsonAsync<List<BowlGame>>("api/GetGames");
            var entriesTask = Http.GetFromJsonAsync<List<BracketEntry>>("api/GetEntries");
            var poolsTask = Http.GetFromJsonAsync<List<BowlPool>>("api/GetPools");
            var myEntriesTask = FetchMyEntriesSafe(); // Fetch proactively for fallback logic

            await Task.WhenAll(gamesTask, entriesTask, poolsTask, myEntriesTask);

            allGames = (await gamesTask ?? new()).OrderBy(g => g.StartTime).ToList();
            games = allGames.ToList();
            allEntries = await entriesTask ?? new();
            var allPools = await poolsTask ?? new();
            var myEntries = await myEntriesTask;

            // 1. Filter Pools (Active Season Only)
            poolList = allPools.Where(p => !p.IsArchived).ToList();

            // 2. Build the Bracket Tree
            _feederMap = allGames
                .Where(g => !string.IsNullOrEmpty(g.NextGameId))
                .ToLookup(g => g.NextGameId!);

            // 3. Pre-fill Simulation with Reality
            foreach(var game in allGames.Where(g => g.Status == GameStatus.Final))
            {
                var winner = GetRealWinner(game);
                if (!string.IsNullOrEmpty(winner))
                {
                    simulatedWinners[game.Id] = winner;
                }
            }

            // 4. Determine Current Pool (Smart Default Logic)
            BowlPool? targetPool = null;

            // A. Query Param
            if (!string.IsNullOrEmpty(QueryPoolId))
            {
                targetPool = poolList.FirstOrDefault(p => p.Id == QueryPoolId);
            }

            // B. Local Storage
            if (targetPool == null)
            {
                try
                {
                    var savedPoolId = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "lastSelectedPoolId");
                    if (!string.IsNullOrEmpty(savedPoolId))
                    {
                        targetPool = poolList.FirstOrDefault(p => p.Id == savedPoolId);
                    }
                }
                catch { /* Ignore JS errors */ }
            }

            // C. My Entries (Most recent active pool I'm in)
            if (targetPool == null && myEntries.Any())
            {
                var lastEntry = myEntries.OrderByDescending(e => e.CreatedOn).FirstOrDefault();
                if (lastEntry != null)
                {
                    targetPool = poolList.FirstOrDefault(p => p.Id == lastEntry.PoolId);
                }
            }

            // D. Fallback to First
            if (targetPool == null && poolList.Any())
            {
                targetPool = poolList.First();
            }

            selectedPoolId = targetPool?.Id ?? "";
            
            UpdateFilteredEntries();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
        finally { isLoading = false; }
    }

    private async Task<List<BracketEntry>> FetchMyEntriesSafe()
    {
        try 
        {
            var auth = await AuthStateProvider.GetAuthenticationStateAsync();
            if (auth.User.Identity?.IsAuthenticated == true)
            {
                return await Http.GetFromJsonAsync<List<BracketEntry>>("api/GetMyEntries") ?? new();
            }
        }
        catch { /* Ignore auth errors */ }
        return new();
    }

    // --- FILTERING LOGIC ---
    
    private async Task OnPoolChanged(ChangeEventArgs e)
    {
        selectedPoolId = e.Value?.ToString() ?? "";
        if (!string.IsNullOrEmpty(selectedPoolId))
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "lastSelectedPoolId", selectedPoolId);
        }
        UpdateFilteredEntries();
    }

    private void UpdateFilteredEntries()
    {
        if (string.IsNullOrEmpty(selectedPoolId))
        {
            filteredEntries = new();
            games = allGames.ToList();
        }
        else
        {
            filteredEntries = allEntries.Where(e => e.PoolId == selectedPoolId).ToList();
            
            var pool = poolList.FirstOrDefault(p => p.Id == selectedPoolId);
            if (pool != null && pool.GameIds != null && pool.GameIds.Any())
            {
                games = allGames.Where(g => pool.GameIds.Contains(g.Id)).OrderBy(g => g.StartTime).ToList();
            }
            else
            {
                games = allGames.ToList();
            }
        }
        Recalculate();
    }

    // --- SMART BRACKET LOGIC ---

    private List<string> GetSelectableTeams(BowlGame game)
    {
        // Use "Entrants" (Inputs) so the list doesn't collapse after selecting a winner
        var entrants = GetEntrantsForGame(game);
        return entrants.OrderBy(t => t).ToList();
    }

    private IEnumerable<string> GetPotentialWinnersForGame(BowlGame game)
    {
        // 0. Calculate Valid Entrants first (Recursive Check)
        // We must know who is actually playing to validate any simulation or reality.
        var validEntrants = GetEntrantsForGame(game).ToList();

        // PRIORITY 1: Simulation (Allows overriding reality)
        if (simulatedWinners.TryGetValue(game.Id, out var simPick))
        {
            // CRITICAL FIX: Only return the simPick if they are actually a valid entrant.
            // If I picked "Team A" in the Final, but then went back and changed the Semi-Final 
            // so "Team A" lost, "Team A" is no longer a valid entrant here.
            // We ignore the stale pick and fall through to "Undecided".
            if (validEntrants.Contains(simPick, StringComparer.OrdinalIgnoreCase))
            {
                return new[] { simPick };
            }
        }

        // PRIORITY 2: Reality
        if (game.Status == GameStatus.Final)
        {
            var realWinner = GetRealWinner(game);
            return string.IsNullOrEmpty(realWinner) ? Enumerable.Empty<string>() : new[] { realWinner };
        }

        // PRIORITY 3: Undecided -> Return all valid entrants
        return validEntrants;
    }

    private IEnumerable<string> GetEntrantsForGame(BowlGame game)
    {
        var entrants = new HashSet<string>();

        // A. Fixed Teams
        if (!string.IsNullOrEmpty(game.TeamHome) && !game.TeamHome.Equals("TBD", StringComparison.OrdinalIgnoreCase))
            entrants.Add(game.TeamHome);
            
        if (!string.IsNullOrEmpty(game.TeamAway) && !game.TeamAway.Equals("TBD", StringComparison.OrdinalIgnoreCase))
            entrants.Add(game.TeamAway);

        // B. Feeder Games (Recursive)
        if (_feederMap != null && _feederMap.Contains(game.Id))
        {
            foreach (var feeder in _feederMap[game.Id])
            {
                var incoming = GetPotentialWinnersForGame(feeder);
                foreach (var team in incoming) entrants.Add(team);
            }
        }

        return entrants;
    }

    // --- INTERACTION ---

    private void ToggleSimWinner(string gameId, string team)
    {
        if (simulatedWinners.ContainsKey(gameId) && simulatedWinners[gameId] == team)
        {
            // If we uncheck a winner, we need to verify if the game is Final.
            // If Final, we should revert to the Real winner (or keep it selected)
            // But simplified: Toggle Off removes from dict.
            simulatedWinners.Remove(gameId);
            
            // If game is final, re-add real winner so it doesn't look empty? 
            // Or let it be empty (undecided)?
            // User requested: "behave same as incomplete". Incomplete can be untoggled.
        }
        else
        {
            simulatedWinners[gameId] = team;
        }
        Recalculate();
    }

    private void SetSimWinner(string gameId, string? team)
    {
        if (string.IsNullOrEmpty(team))
            simulatedWinners.Remove(gameId);
        else
            simulatedWinners[gameId] = team;
            
        Recalculate();
    }

    private void ResetSimulation()
    {
        simulatedWinners.Clear();
        // Restore Reality
        foreach(var game in games.Where(g => g.Status == GameStatus.Final))
        {
            var w = GetRealWinner(game);
            if (!string.IsNullOrEmpty(w)) simulatedWinners[game.Id] = w;
        }
        Recalculate();
    }

    private void Recalculate()
    {
        projectedStandings = WhatIfScoringEngine.Calculate(games, filteredEntries, simulatedWinners);
    }

    // --- STYLING HELPERS ---

    // Logic to only show "Reset" if we have deviated from reality
    private bool HasActiveSimulation
    {
        get
        {
            foreach(var kvp in simulatedWinners)
            {
                var game = games.FirstOrDefault(g => g.Id == kvp.Key);
                if (game == null) continue;
                
                // If we predicted a future game, that's active.
                if (game.Status != GameStatus.Final) return true;
                
                // If we changed history, that's active.
                if (GetRealWinner(game) != kvp.Value) return true;
            }
            // If we have FEWER items than finalized games (unselected a final game), that's also a deviation
            // But simplest check matches 99% of use cases.
            return false;
        }
    }

    private string GetSimClass(string gameId, string team, List<string> validOptions)
    {
        // 1. Check if we have a simulated winner
        if (simulatedWinners.TryGetValue(gameId, out var simPick))
        {
            // 2. Validate: Is the stored winner actually a valid option right now?
            // If I picked "Team A", but "Team A" was eliminated upstream, 
            // validOptions will NOT contain "Team A". 
            // In that case, we treat the game as Undecided (no styles).
            if (validOptions.Contains(simPick, StringComparer.OrdinalIgnoreCase))
            {
                // The pick is valid. Apply Win/Loss styles.
                return simPick == team ? "active-win" : "active-loss";
            }
        }
        
        // No valid winner selected -> Default style (Selectable)
        return "bg-white"; 
    }

    private string GetRealWinner(BowlGame game)
    {
        if (game.Status != GameStatus.Final) return "";
        int h = game.TeamHomeScore ?? 0;
        int a = game.TeamAwayScore ?? 0;
        if (h > a) return game.TeamHome;
        if (a > h) return game.TeamAway;
        return "";
    }

    private string GetCellClass(BowlGame game, string pick)
    {
        if (string.IsNullOrEmpty(pick)) return "";
        
        // Check if the picked team is still a valid entrant (not eliminated)
        var validEntrants = GetPotentialWinnersForGame(game).ToList();
        bool isEliminated = !validEntrants.Any(e => string.Equals(e, pick, StringComparison.OrdinalIgnoreCase));
        
        // If the team has been eliminated, show red even if no winner selected yet
        if (isEliminated)
        {
            return "cell-loss";
        }
        
        // Check if a winner has been selected for this game
        string winner = "";
        if (simulatedWinners.ContainsKey(game.Id)) winner = simulatedWinners[game.Id];

        if (!string.IsNullOrEmpty(winner))
        {
            return string.Equals(pick, winner, StringComparison.OrdinalIgnoreCase) ? "cell-win" : "cell-loss";
        }
        
        return "";
    }
}
