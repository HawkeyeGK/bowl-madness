@page "/what-if"
@using BowlPoolManager.Core.Domain
@using BowlPoolManager.Core
@using BowlPoolManager.Core.Helpers
@using BowlPoolManager.Client.Services

@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@inject ISeasonService SeasonService
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject AuthenticationStateProvider AuthStateProvider

<PageTitle>Path to Victory</PageTitle>

<style>
    /* 1. SCROLL CONTAINER */
    .matrix-container {
        display: block;
        width: 100%;
        max-width: 100%;
        height: calc(100vh - 190px); 
        overflow: auto; 
        border: 1px solid #dee2e6;
        background-color: white;
        position: relative;
        -webkit-overflow-scrolling: touch;
    }

    /* 2. TABLE BASE */
    .matrix-table {
        border-collapse: separate; 
        border-spacing: 0;
        table-layout: fixed; /* Force fixed layout */
        width: auto; /* Let it grow manually based on columns */
        margin-bottom: 0;
    }

    /* 3. COLUMNS */
    .matrix-table th, 
    .matrix-table td {
        vertical-align: middle;
        text-align: center;
        width: 70px;      /* FIXED WIDTH */
        min-width: 70px;
        max-width: 70px;
        padding: 4px;
        overflow: hidden;
    }

    /* 4. STICKY HEADERS (Top Row) */
    .matrix-table th {
        position: sticky;
        top: 0;
        z-index: 20; 
        background-color: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        padding: 0.5rem;
        box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.1);
        white-space: normal; /* ALLOW WRAP */
        height: auto;
        font-size: 0.75rem;
        line-height: 1.1;
    }

    /* 5. STICKY FIRST COLUMN (Left Column) */
    .matrix-table td.sticky-col, .matrix-table th.sticky-col-header  {
        position: sticky;
        left: 0;
        z-index: 10; 
        background-color: #fff !important; 
        border-right: 2px solid #dee2e6;
        font-weight: 500;
        width: 180px;      /* FIXED WIDTH FOR NAMES */
        min-width: 180px;
        max-width: 180px;
        text-align: left; /* Align names left */
        box-shadow: 2px 0 2px -1px rgba(0, 0, 0, 0.1);
    }
    .matrix-table th.sticky-col-header {
        z-index: 30; /* Corner overlap */
        background-color: #e9ecef !important;
        text-align: center;
    }

    /* 7. ROW HOVER */
    .matrix-table tr:hover td { background-color: #f1f3f5; }
    .matrix-table tr:hover td.sticky-col { background-color: #e9ecef !important; }

    /* Sim Controls */
    .sim-control-btn {
        cursor: pointer;
        padding: 2px;
        border-radius: 4px;
        border: 1px solid #ced4da;
        margin: 2px auto;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 28px;
        background-color: white;
    }
    .sim-control-btn:hover { filter: brightness(0.95); background-color: #e9ecef; }
    .sim-control-btn.active-win {
        background-color: #d1e7dd; 
        border-color: #198754;
        box-shadow: inset 0 0 0 1px #198754;
    }
    .sim-control-btn.active-loss {
        opacity: 0.4;
        background-color: #f8d7da;
    }
    
    /* Colors */
    .cell-win { background-color: #d1e7dd !important; color: #0f5132; }
    .cell-loss { background-color: #f8d7da !important; color: #842029; opacity: 0.6; }

    .team-logo-sm { width: 18px; height: 18px; object-fit: contain; margin-right: 2px; }
    .team-abbrev { font-size: 0.75rem; font-weight: bold; }

    @@media print {
        @@page { size: landscape; margin: 0.5cm; }
        
        /* Hide Navigation & Layout */
        .sidebar, .top-row, .navbar, header, footer { display: none !important; }
        
        /* Layout Resets */
        .container-fluid {
            width: 100% !important;
            max-width: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Matrix Container: Remove scroll & constraints */
        .matrix-container {
            height: auto !important;
            overflow: visible !important;
            border: none !important;
            width: 100% !important;
            max-width: none !important;
            display: block !important;
        }

        /* Table: Allow full width & wrapping */
        .matrix-table {
            width: 100% !important;
            table-layout: auto !important;
        }

        /* Cells & Headers: Reduce size & remove stickiness */
        .matrix-table th, 
        .matrix-table td {
            position: static !important; /* Remove sticky */
            font-size: 8pt !important;   /* Reduce text size */
            padding: 1px !important;     /* Tighter padding */
            width: auto !important;      /* Allow automatic sizing */
            min-width: 0 !important;
            max-width: none !important; /* Uncap width */
            border: 1px solid #000 !important; /* High contrast borders */
        }
        
        /* Remove specific sticky styles */
        .sticky-col, .sticky-col-header {
            position: static !important;
            border: 1px solid #000 !important;
            box-shadow: none !important;
        }

        /* Visual Tweaks for Print */
        .team-logo-sm { width: 12px !important; height: 12px !important; margin-right: 1px !important; }
        .team-abbrev { font-size: 7pt !important; }
        .badge { border: none !important; padding: 0 !important; font-size: 7pt !important; }
        
        /* Force background colors */
        .cell-win, .cell-loss, .active-win, .active-loss {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
    }
</style>

<div class="container-fluid mt-3 px-4">
    <div class="d-flex justify-content-between align-items-end mb-3 d-print-none">
        
        @* LEFT SIDE: Title + Pool Selector *@
        <div class="d-flex flex-column gap-2">
            <div class="d-flex align-items-center gap-3">
                <h1 class="h3 fw-bold mb-0"><i class="bi bi-signpost-split-fill text-primary"></i> Path to Victory</h1>
            </div>

            @* POOL SELECTOR *@
            @if(poolList.Count > 1)
            {
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small fw-bold">Pool:</span>
                    <select class="form-select form-select-sm shadow-sm" style="width: auto; min-width: 200px;" @onchange="OnPoolChanged">
                        @foreach(var pool in poolList)
                        {
                            <option value="@pool.Id" selected="@(pool.Id == selectedPoolId)">@pool.Name</option>
                        }
                    </select>
                </div>
            }
        </div>

        @* RIGHT SIDE: Actions *@
        <div class="d-flex gap-2">
             @if (HasActiveSimulation && !isPrintView)
             {
                <button class="btn btn-outline-danger btn-sm" @onclick="ResetSimulation">
                    <i class="bi bi-arrow-counterclockwise"></i> Reset to Reality
                </button>
             }
             
             <button class="btn btn-sm @(isPrintView ? "btn-secondary" : "btn-outline-secondary") d-print-none" 
                     @onclick="() => isPrintView = !isPrintView">
                 <i class="bi @(isPrintView ? "bi-table" : "bi-printer")"></i> 
                 @(isPrintView ? "Exit Print View" : "Printer Friendly View")
             </button>
        </div>
    </div>
    
    @if (isPrintView)
    {
        <div class="d-print-none alert alert-info py-2 mb-3">
            <i class="bi bi-info-circle-fill me-2"></i>
            <strong>Printer Friendly Mode Active:</strong> The table has been split into smaller chunks to fit on standard paper. Use <code>Ctrl+P</code> to print.
        </div>
    }

    @if (isLoading)
    {
        <div class="d-flex justify-content-center py-5">
            <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
        </div>
    }
    else if (!poolList.Any())
    {
        <div class="text-center py-5">
            <i class="bi bi-hourglass-split display-1 text-secondary opacity-50"></i>
            <h2 class="mt-3 text-secondary">Awaiting Kickoff</h2>
            <p class="lead text-muted">Path to Victory unlocks when the first pool of the season opens.</p>
        </div>
    }
    else if (isPrintView)
    {
        @* PRINT VIEW: Split Table *@
        <div class="print-container">
            @foreach (var chunk in GetGameChunks())
            {
                <div class="mb-4 break-after-page">
                    <table class="table table-bordered table-sm matrix-table custom-print-table">
                        <thead>
                            <tr>
                                <th style="width: 150px;">Player</th>
                                @foreach (var game in chunk)
                                {
                                    <th class="text-center">
                                        <div class="small fw-bold text-truncate" style="max-width: 60px;">@game.BowlName</div>
                                        <div class="badge bg-light text-secondary border">@game.PointValue</div>
                                        <div class="d-block mt-1" style="font-size: 0.65rem;">
                                            @if(simulatedWinners.ContainsKey(game.Id))
                                            {
                                                var w = simulatedWinners[game.Id];
                                                <span class="badge bg-success text-white">@GetTeamAbbrev(w)</span>
                                            }
                                            else
                                            {
                                                <span>-</span>
                                            }
                                        </div>
                                    </th>
                                }
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var row in projectedStandings)
                            {
                                <tr>
                                    <td class="fw-bold">
                                        <div class="d-flex justify-content-between">
                                            <span class="text-truncate" style="max-width: 110px;">@row.Entry.PlayerName</span>
                                            <span class="badge bg-primary rounded-pill">@row.Score</span>
                                        </div>
                                    </td>
                                    @foreach (var game in chunk)
                                    {
                                        var pick = row.Entry.Picks != null && row.Entry.Picks.ContainsKey(game.Id) ? row.Entry.Picks[game.Id] : "";
                                        <td class="text-center @GetCellClass(game, pick)">
                                            @if (!string.IsNullOrEmpty(pick))
                                            {
                                                <span class="fw-bold" style="font-size: 0.7rem;">@GetTeamAbbrev(pick)</span>
                                            }
                                        </td>
                                    }
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    }
    else
    {
        <div class="matrix-container shadow-sm">
            <table class="table mb-0 matrix-table table-bordered">
                <thead>
                    <tr>
                        <th class="sticky-col-header">
                            <div class="d-flex justify-content-between text-muted small px-1">
                                <span>Player</span>
                                <span>Proj.</span>
                            </div>
                        </th>
                        @foreach (var game in games)
                        {
                            <th>
                                <div class="fw-bold mb-1 text-truncate" title="@game.BowlName">
                                    @game.BowlName
                                </div>
                                <div class="badge bg-light text-secondary border mb-1" style="font-size: 0.65rem;">@game.PointValue</div>
                                
                                @{
                                    var options = GetSelectableTeams(game);
                                }
                                
                                @if(options.Count <= 2) 
                                {
                                    <div class="d-flex flex-column gap-1">
                                        @foreach(var teamName in options)
                                        {
                                            var logo = GetTeamLogo(teamName);
                                            var abbr = GetTeamAbbrev(teamName);
                                            <div class="sim-control-btn @GetSimClass(game.Id, teamName, options)" 
                                                 title="@teamName"
                                                 @onclick="() => ToggleSimWinner(game.Id, teamName)">
                                                @if(!string.IsNullOrEmpty(logo))
                                                {
                                                    <img src="@logo" class="team-logo-sm" />
                                                }
                                                <span class="team-abbrev">@abbr</span>
                                            </div>
                                        }
                                    </div>
                                }
                                else
                                {
                                    <select class="form-select form-select-sm p-1" style="font-size: 0.65rem;" 
                                            value="@(simulatedWinners.ContainsKey(game.Id) ? simulatedWinners[game.Id] : "")"
                                            @onchange="@(e => SetSimWinner(game.Id, e.Value?.ToString()))">
                                        <option value="">?</option>
                                        @foreach(var teamName in options)
                                        {
                                            <option value="@teamName">@GetTeamAbbrev(teamName)</option>
                                        }
                                    </select>
                                }
                            </th>
                        }
                    </tr>
                </thead>
                <tbody>
                    @foreach (var row in projectedStandings)
                    {
                        <tr>
                            <td class="sticky-col">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span class="text-truncate" style="max-width: 160px;" title="@row.Entry.PlayerName">
                                        <span class="text-muted small me-1">@row.Rank.</span>
                                        @row.Entry.PlayerName
                                    </span>
                                    <span class="badge bg-primary rounded-pill">@row.Score</span>
                                </div>
                            </td>

                            @foreach (var game in games)
                            {
                                var pick = row.Entry.Picks != null && row.Entry.Picks.ContainsKey(game.Id) ? row.Entry.Picks[game.Id] : "";
                                <td class="@GetCellClass(game, pick)">
                                    @if (!string.IsNullOrEmpty(pick))
                                    {
                                        var logo = GetTeamLogo(pick);
                                        var abbr = GetTeamAbbrev(pick);
                                        <div class="d-flex align-items-center justify-content-center" title="@pick">
                                            @if(!string.IsNullOrEmpty(logo))
                                            {
                                                <img src="@logo" class="team-logo-sm" />
                                            }
                                            <span class="team-abbrev">@abbr</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <span class="text-muted small">-</span>
                                    }
                                </td>
                            }
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
</div>

@code {
    private bool isLoading = true;
    private List<BowlGame> games = new();
    private List<BowlGame> allGames = new();
    
    // Raw Data
    private List<BracketEntry> allEntries = new();
    private List<BowlPool> poolList = new();
    
    // Filtered State
    private string selectedPoolId = "";
    private List<BracketEntry> filteredEntries = new();
    
    // Print View State
    private bool isPrintView = false;
    private const int PRINT_CHUNK_SIZE = 15;

    private IEnumerable<List<BowlGame>> GetGameChunks()
    {
        return games
            .Select((x, i) => new { Index = i, Value = x })
            .GroupBy(x => x.Index / PRINT_CHUNK_SIZE)
            .Select(x => x.Select(v => v.Value).ToList());
    }
    
    // Simulation State
    private Dictionary<string, string> simulatedWinners = new();
    private List<LeaderboardRow> projectedStandings = new();
    
    // Cache for efficient Team Info Lookup
    private Dictionary<string, TeamInfo> teamLookup = new(StringComparer.OrdinalIgnoreCase);

    // Smart Bracket Map: Key = TargetGameId, Value = List of Games that feed into it
    private ILookup<string, BowlGame>? _feederMap;

    [SupplyParameterFromQuery(Name = "poolId")]
    public string? QueryPoolId { get; set; }
    
    private string currentSeasonId = "";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // 0. Fetch Current Season
            var currentSeason = await SeasonService.GetCurrentSeasonAsync();
            currentSeasonId = currentSeason?.Id ?? "";

            var gamesTask = Http.GetFromJsonAsync<List<BowlGame>>($"api/GetGames?seasonId={currentSeasonId}");
            var entriesTask = Http.GetFromJsonAsync<List<BracketEntry>>($"api/GetEntries?seasonId={currentSeasonId}");
            var poolsTask = Http.GetFromJsonAsync<List<BowlPool>>($"api/GetPools?seasonId={currentSeasonId}");
            var myEntriesTask = FetchMyEntriesSafe(); // Fetch proactively for fallback logic

            await Task.WhenAll(gamesTask, entriesTask, poolsTask, myEntriesTask);

            allGames = (await gamesTask ?? new()).OrderBy(g => g.StartTime).ToList();
            games = allGames.ToList();
            allEntries = await entriesTask ?? new();
            var allPools = await poolsTask ?? new();
            var myEntries = await myEntriesTask;

            // 1. Filter Pools (Active Season Only AND Open)
            poolList = allPools.Where(p => !p.IsArchived && DateTime.UtcNow >= p.LockDate).ToList();

            // 2. Build the Bracket Tree & Populate Team Lookup
            _feederMap = allGames
                .Where(g => !string.IsNullOrEmpty(g.NextGameId))
                .ToLookup(g => g.NextGameId!);

            foreach(var g in allGames)
            {
                if (!string.IsNullOrEmpty(g.TeamHome) && g.HomeTeamInfo != null) 
                    teamLookup[g.TeamHome] = g.HomeTeamInfo;
                    
                if (!string.IsNullOrEmpty(g.TeamAway) && g.AwayTeamInfo != null) 
                    teamLookup[g.TeamAway] = g.AwayTeamInfo;
            }

            // 3. Pre-fill Simulation with Reality
            foreach(var game in allGames.Where(g => g.Status == GameStatus.Final))
            {
                var winner = GetRealWinner(game);
                if (!string.IsNullOrEmpty(winner))
                {
                    simulatedWinners[game.Id] = winner;
                }
            }

            // 4. Determine Current Pool (Smart Default Logic)
            BowlPool? targetPool = null;

            // A. Query Param
            if (!string.IsNullOrEmpty(QueryPoolId))
            {
                targetPool = poolList.FirstOrDefault(p => p.Id == QueryPoolId);
            }

            // B. Local Storage
            if (targetPool == null)
            {
                try
                {
                    var savedPoolId = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "lastSelectedPoolId");
                    if (!string.IsNullOrEmpty(savedPoolId))
                    {
                        targetPool = poolList.FirstOrDefault(p => p.Id == savedPoolId);
                    }
                }
                catch { /* Ignore JS errors */ }
            }

            // C. My Entries (Most recent active pool I'm in)
            if (targetPool == null && myEntries.Any())
            {
                var lastEntry = myEntries.OrderByDescending(e => e.CreatedOn).FirstOrDefault();
                if (lastEntry != null)
                {
                    targetPool = poolList.FirstOrDefault(p => p.Id == lastEntry.PoolId);
                }
            }

            // D. Fallback to First
            if (targetPool == null && poolList.Any())
            {
                targetPool = poolList.First();
            }

            selectedPoolId = targetPool?.Id ?? "";
            
            UpdateFilteredEntries();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
        finally { isLoading = false; }
    }

    private async Task<List<BracketEntry>> FetchMyEntriesSafe()
    {
        try 
        {
            var auth = await AuthStateProvider.GetAuthenticationStateAsync();
            if (auth.User.Identity?.IsAuthenticated == true)
            {
                return await Http.GetFromJsonAsync<List<BracketEntry>>($"api/GetMyEntries?seasonId={currentSeasonId}") ?? new();
            }
        }
        catch { /* Ignore auth errors */ }
        return new();
    }

    // --- FILTERING LOGIC ---
    
    private async Task OnPoolChanged(ChangeEventArgs e)
    {
        selectedPoolId = e.Value?.ToString() ?? "";
        if (!string.IsNullOrEmpty(selectedPoolId))
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "lastSelectedPoolId", selectedPoolId);
        }
        UpdateFilteredEntries();
    }

    private void UpdateFilteredEntries()
    {
        if (string.IsNullOrEmpty(selectedPoolId))
        {
            filteredEntries = new();
            games = allGames.ToList();
        }
        else
        {
            filteredEntries = allEntries.Where(e => e.PoolId == selectedPoolId).ToList();
            
            var pool = poolList.FirstOrDefault(p => p.Id == selectedPoolId);
            if (pool != null && pool.GameIds != null && pool.GameIds.Any())
            {
                games = allGames.Where(g => pool.GameIds.Contains(g.Id)).OrderBy(g => g.StartTime).ToList();
            }
            else
            {
                games = allGames.ToList();
            }
        }
        Recalculate();
    }

    // --- SMART BRACKET LOGIC ---

    private List<string> GetSelectableTeams(BowlGame game)
    {
        // Use "Entrants" (Inputs) so the list doesn't collapse after selecting a winner
        var entrants = GetEntrantsForGame(game);
        return entrants.OrderBy(t => t).ToList();
    }

    private IEnumerable<string> GetPotentialWinnersForGame(BowlGame game)
    {
        // 0. Calculate Valid Entrants first (Recursive Check)
        // We must know who is actually playing to validate any simulation or reality.
        var validEntrants = GetEntrantsForGame(game).ToList();

        // PRIORITY 1: Simulation (Allows overriding reality)
        if (simulatedWinners.TryGetValue(game.Id, out var simPick))
        {
            // CRITICAL FIX: Only return the simPick if they are actually a valid entrant.
            // If I picked "Team A" in the Final, but then went back and changed the Semi-Final 
            // so "Team A" lost, "Team A" is no longer a valid entrant here.
            // We ignore the stale pick and fall through to "Undecided".
            if (validEntrants.Contains(simPick, StringComparer.OrdinalIgnoreCase))
            {
                return new[] { simPick };
            }
        }

        // PRIORITY 2: Reality
        if (game.Status == GameStatus.Final)
        {
            var realWinner = GetRealWinner(game);
            return string.IsNullOrEmpty(realWinner) ? Enumerable.Empty<string>() : new[] { realWinner };
        }

        // PRIORITY 3: Undecided -> Return all valid entrants
        return validEntrants;
    }

    private IEnumerable<string> GetEntrantsForGame(BowlGame game)
    {
        var entrants = new HashSet<string>();

        // Check if this game has feeder games
        bool hasFeederGames = _feederMap != null && _feederMap.Contains(game.Id);

        // A. Fixed Teams (only if no feeder games)
        // For playoff games with feeders, teams are determined by feeder winners (real or simulated),
        // not by the propagated TeamHome/TeamAway which may be stale.
        if (!hasFeederGames)
        {
            if (!string.IsNullOrEmpty(game.TeamHome) && !game.TeamHome.Equals("TBD", StringComparison.OrdinalIgnoreCase))
                entrants.Add(game.TeamHome);
                
            if (!string.IsNullOrEmpty(game.TeamAway) && !game.TeamAway.Equals("TBD", StringComparison.OrdinalIgnoreCase))
                entrants.Add(game.TeamAway);
        }

        // B. Feeder Games (Recursive)
        if (hasFeederGames)
        {
            if (_feederMap != null && _feederMap.Contains(game.Id))
            {
                foreach (var feeder in _feederMap[game.Id])
                {
                    var incoming = GetPotentialWinnersForGame(feeder);
                    foreach (var team in incoming) entrants.Add(team);
                }
            }
        }

        return entrants;
    }

    // --- INTERACTION ---

    private void ToggleSimWinner(string gameId, string team)
    {
        if (simulatedWinners.ContainsKey(gameId) && simulatedWinners[gameId] == team)
        {
            // If we uncheck a winner, we need to verify if the game is Final.
            // If Final, we should revert to the Real winner (or keep it selected)
            // But simplified: Toggle Off removes from dict.
            simulatedWinners.Remove(gameId);
            
            // If game is final, re-add real winner so it doesn't look empty? 
            // Or let it be empty (undecided)?
            // User requested: "behave same as incomplete". Incomplete can be untoggled.
        }
        else
        {
            simulatedWinners[gameId] = team;
        }
        Recalculate();
    }

    private void SetSimWinner(string gameId, string? team)
    {
        if (string.IsNullOrEmpty(team))
            simulatedWinners.Remove(gameId);
        else
            simulatedWinners[gameId] = team;
            
        Recalculate();
    }

    private void ResetSimulation()
    {
        simulatedWinners.Clear();
        // Restore Reality
        foreach(var game in games.Where(g => g.Status == GameStatus.Final))
        {
            var w = GetRealWinner(game);
            if (!string.IsNullOrEmpty(w)) simulatedWinners[game.Id] = w;
        }
        Recalculate();
    }

    private void Recalculate()
    {
        projectedStandings = WhatIfScoringEngine.Calculate(games, filteredEntries, simulatedWinners);
    }

    // --- STYLING HELPERS ---

    // Logic to only show "Reset" if we have deviated from reality
    private bool HasActiveSimulation
    {
        get
        {
            foreach(var kvp in simulatedWinners)
            {
                var game = games.FirstOrDefault(g => g.Id == kvp.Key);
                if (game == null) continue;
                
                // If we predicted a future game, that's active.
                if (game.Status != GameStatus.Final) return true;
                
                // If we changed history, that's active.
                if (GetRealWinner(game) != kvp.Value) return true;
            }
            // If we have FEWER items than finalized games (unselected a final game), that's also a deviation
            // But simplest check matches 99% of use cases.
            return false;
        }
    }

    private string GetSimClass(string gameId, string team, List<string> validOptions)
    {
        // 1. Check if we have a simulated winner
        if (simulatedWinners.TryGetValue(gameId, out var simPick))
        {
            // 2. Validate: Is the stored winner actually a valid option right now?
            // If I picked "Team A", but "Team A" was eliminated upstream, 
            // validOptions will NOT contain "Team A". 
            // In that case, we treat the game as Undecided (no styles).
            if (validOptions.Contains(simPick, StringComparer.OrdinalIgnoreCase))
            {
                // The pick is valid. Apply Win/Loss styles.
                return simPick == team ? "active-win" : "active-loss";
            }
        }
        
        // No valid winner selected -> Default style (Selectable)
        return "bg-white"; 
    }

    private string GetRealWinner(BowlGame game)
    {
        if (game.Status != GameStatus.Final) return "";
        int h = game.TeamHomeScore ?? 0;
        int a = game.TeamAwayScore ?? 0;
        if (h > a) return game.TeamHome;
        if (a > h) return game.TeamAway;
        return "";
    }

    private string GetCellClass(BowlGame game, string pick)
    {
        if (string.IsNullOrEmpty(pick)) return "";
        
        // Check if the picked team is still a valid entrant (not eliminated)
        var validEntrants = GetPotentialWinnersForGame(game).ToList();
        bool isEliminated = !validEntrants.Any(e => string.Equals(e, pick, StringComparison.OrdinalIgnoreCase));
        
        // If the team has been eliminated, show red even if no winner selected yet
        if (isEliminated)
        {
            return "cell-loss";
        }
        
        // Check if a winner has been selected for this game
        string winner = "";
        if (simulatedWinners.ContainsKey(game.Id)) winner = simulatedWinners[game.Id];

        if (!string.IsNullOrEmpty(winner))
        {
            return string.Equals(pick, winner, StringComparison.OrdinalIgnoreCase) ? "cell-win" : "cell-loss";
        }
        
        return "";
    }
    
    private string GetTeamLogo(string teamName)
    {
        if (string.IsNullOrEmpty(teamName)) return "";
        return teamLookup.TryGetValue(teamName, out var info) ? info.PrimaryLogoUrl : "";
    }

    private string GetTeamAbbrev(string teamName)
    {
        if (string.IsNullOrEmpty(teamName)) return "";
        if (teamLookup.TryGetValue(teamName, out var info) && !string.IsNullOrEmpty(info.Abbreviation)) 
            return info.Abbreviation;
            
        // Fallback: Use first 3 chars or predefined map if needed, 
        // but typically all teams in DB have abbrevs.
        // If TBD, return TBD
        if (teamName.Length > 4 && !teamName.Contains(" ")) return teamName.Substring(0, 3).ToUpper();
        
        return teamName; // Return full name if short enough or TBD
    }
}
